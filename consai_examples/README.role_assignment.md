# Role Assignmentについて

RoleAssignmentノードの仕事は、ロボットの役割（ロール）を決めることです

## 仕様

### ロールの管理

- フィールド上のロボット1台に対して**必ず**1つのロールが割り当てられます
  - 実装としては、**ロボットID**が割り当てられます
- ロールはリストで管理されており、インデックスの小さいものが一番優先度が高いです
  - 優先度の高いロールからロボットが割り当てられます

### 特別なロール

- `GOALIE`ロールはRoleAssignmentノード起動時（game.py起動時）に担当するロボットが決ます
- `ATTACKER`ロールは常にいずれかのロボットが担当する優先度の高いロールです
  - ボールを積極的に蹴るロールのため、いなくなると誰もボールを蹴らなくなります
- `ATTACKER`ロールを担当するロボットが退場した場合、
代わりに、**最もボールに近いロール**のロボットが、`ATTACKER`を担当します
- `SUBSTITUION`ロールは交代のためにフィールド外へ移動するロールで、レフェリーから受け取る`max_allowed_bots`情報をもとに割り当てられます
  - レッドカードにより退場するロボットにも割り当てられます
- `SUBSTITUION`は優先度の低いロールから順に**上書き**されます
  - 優先度の低いロールに重要な機能を持たせると、イエローカード発行時に優先的に退場するので注意してください

### 初期化

- `RoleAssignemnt`の引数で、`GOALIE`を担当するロボットIDと自チームの色を設定します
- すべてのロールは**無担当**で初期化されます

### 更新

- フィールド上にいるロボットを確認します
- ロボットがフィールドから退場していた場合、そのロボットが担当していたロールを無担当にします
- 担当者がいないロールにロボットIDを数字が小さい順に割り当てます
  - 優先度の高いロールにはIDの小さいロボットが割り当てられます
- 優先度の高いロールに空きが出ないように担当を並べ替えます
  - 優先度の最も低いロールから、優先度の高い無担当ロールへ割り当てます
  - `GOALIE`ロールは空きがあっても代わりのロボットが割り当てられません
- 更新関数の引数がセットされていれば、`ATTACKER`ロールのロボットとボールに一番近いロボットと交代します
  - 例えば以下のような条件で`ATTACKER`の更新を止めるとよいです
    - ボールが止まっている　かつ
    - ボールがディフェンスエリア外にある　かつ
    - ボールプレースメントではない　かつ
    - ペナルティシュートアウトではない
- max_alowed_botsがロボットの最大数(11)より小さいとき、
その差分だけ優先度の低いロールを`SUBSTITUION`に上書きします
- 最後に、担当者に変更があったロールのリストを返します

## 定数、クラス

`RoleName`

- ロールを定義したenum Classです
- ロールの数とフィールド上のロボットの数は一致しない場合があります
- ロールが増えるほど、戦略のバリエーションが増えます（複雑さも増えます）
  - 将来的にはコンフィグファイルで設定したいです

```python
class RoleName(Enum):
    GOALIE = 0
    ATTACKER = 1
    ...
```

`decisions`

- 各ロールの意思決定モジュールを格納した辞書データです
- ロールの数と辞書の要素数は一致します

```python

decisions = {
    RoleName.GOALIE : decision_goalie(),
    RoleName.ATTACKER : decision_attacker(),
    ...
    }
```

`Role`

- `RoleName`とロボットIDを格納するクラスです

```python

class Role:
    def __init__(self):
        self._role_name = RoleName.DEFAULT
        self._robot_id = None
```

## 変数

`RoleAssignment.active_role_list`

- アクティブな役割を管理するリストです
- リストのサイズはルール上のロボット最大数と一致します
  - 2023年時点で、最大数は`11`です
- リストにはRoleで定義された役割が格納されます
- 同じ役割を格納しても問題ありません
- リスト内の役割を変更することで、戦略を切り替えられます
    - 将来的には動的にリスト内の構成を切り替えたいです

```python
active_role_list = [Role()] * 11
active_role_list[0].name()  # returns role name, 'RoleName.DEFAULT'
active_role_list[0].robot_id()  # returns robot_id, None
```
